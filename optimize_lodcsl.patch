--- lodcsl.f90.orig	2025-01-08 21:56:00.000000000 +0800
+++ lodcsl.f90	2025-01-08 21:56:00.000000000 +0800
@@ -67,6 +67,12 @@
       USE jcup_I
       USE itjpo_I
       USE ispar_I
+      USE OMP_LIB  ! 添加OpenMP支持
+!
+!   Hash table parameters for duplicate detection
      INTEGER, PARAMETER :: HASH_SIZE = 262144  ! 2^18, 适中的哈希表大小
      INTEGER, DIMENSION(HASH_SIZE) :: hash_table
      INTEGER, DIMENSION(:), ALLOCATABLE :: hash_chain
       IMPLICIT NONE
 !-----------------------------------------------
 !   D u m m y   A r g u m e n t s
@@ -85,10 +91,15 @@
          , NJXN, NPEELN, NOPEN, JLAST, ILAST, IOCCI, NKJI, IFULLI, NU   &
          , JSUB, IQT, NBEG, NEND, JXN, JPI, II, ITEMP, NCOREL
       LOGICAL :: EMPTY, FULL
+      LOGICAL :: is_duplicate
       CHARACTER          :: RECL
       CHARACTER(LEN=256) :: RECORD
+      REAL(DOUBLE) :: start_time, end_time
 !-----------------------------------------------
 !
+!   初始化计时和哈希表
+      start_time = OMP_GET_WTIME()
+      hash_table = 0
 !
 !   Entry message
 !
@@ -126,9 +137,12 @@
 !   Initial allocation for arrays with a dimension dependent
 !   on the number of CSFs; the initial allocation must be
 !   greater than 1
+!   *** 优化: 增加初始分配大小 ***
 !
-      NCFD = 6000
+      NCFD = 50000  ! 增加初始分配，减少重分配次数
 !     NCFD = 2
+      ALLOCATE(hash_chain(NCFD))
+      hash_chain = 0
 
        CALL ALLOC (IQA,  NNNW,  NCFD, 'IQA',   'LODCSL')
        CALL ALLOC (JQSA, NNNW,3,NCFD, 'JQSA',  'LODCSL')
@@ -169,10 +183,17 @@
 !CFF     It is possible that this should be moved to "3 Continue"
 !        where NCF is incremented
          IF (NCF > NCFD) THEN
-            NEWSIZ = NCFD + NCFD/2
+!   *** 优化: 使用2倍增长策略 ***
+            NEWSIZ = NCFD * 2
             CALL RALLOC (IQA,  NNNW,  NEWSIZ, 'IQA',   'LODCSL')
             CALL RALLOC (JQSA, NNNW,3,NEWSIZ, 'JQSA',  'LODCSL')
             CALL RALLOC (JCUPA,NNNW,  NEWSIZ, 'JCUPA', 'LODCSL')
+!   扩展哈希链表
+            DEALLOCATE(hash_chain)
+            ALLOCATE(hash_chain(NEWSIZ))
+            hash_chain(NCFD+1:) = 0
+            WRITE (6, *) 'Reallocated arrays to ', NEWSIZ, ' CSFs'
             NCFD = NEWSIZ
          ENDIF
 !
@@ -445,20 +466,11 @@
 !   Check if this CSF was already in the list; stop with a
 !   message if this is the case
 !
+!   *** 优化: 使用哈希表进行重复检测 ***
          IF (NCF > 1) THEN
-            DO J = 1, NCF - 1
-               DO I = NCORP1, NW
-                  IF (IQ(I,J) /= IQ(I,NCF)) GO TO 17
-                  IF (JQS(1,I,J) /= JQS(1,I,NCF)) GO TO 17
-                  IF (JQS(2,I,J) /= JQS(2,I,NCF)) GO TO 17
-                  IF (JQS(3,I,J) /= JQS(3,I,NCF)) GO TO 17
-               END DO
-               DO I = 1, NOPEN - 1
-                  IF (JCUP(I,J) /= JCUP(I,NCF)) GO TO 17
-               END DO
-            END DO
-            WRITE (ISTDE, *) 'LODCSL: Repeated CSF;'
-            GO TO 26
+            is_duplicate = check_duplicate_hash(NCF, NCORP1, NW, NOPEN)
+            IF (is_duplicate) THEN
+               WRITE (ISTDE, *) 'LODCSL: Repeated CSF;'
+               GO TO 26
+            ENDIF
          ENDIF
 !
 !   Successfully read a CSF; update NREC and read another CSF
@@ -466,6 +478,12 @@
    17    CONTINUE
          NREC = NREC + 3
+!   进度报告
+         IF (MOD(NCF, 10000) == 0) THEN
+            end_time = OMP_GET_WTIME()
+            WRITE (6, *) 'Processed ', NCF, ' CSFs in ', &
+                        end_time - start_time, ' seconds'
+         ENDIF
          GO TO 3
 !
       ELSE
@@ -538,6 +556,9 @@
 !   All done; report
 !
       CALL CONVRT (NCF, RECORD, LENTH)
+      end_time = OMP_GET_WTIME()
+      WRITE (6, *) 'CSF loading completed in ', end_time - start_time, ' seconds'
       WRITE (6, *) 'There are '//RECORD(1:LENTH)//' relativistic CSFs;'
       WRITE (6, *) ' ... load complete;'
 !
@@ -555,6 +576,7 @@
 
       NBLOCK = NBLOCK + 1
       NCFBLK(NBLOCK) = NCF
+      DEALLOCATE(hash_chain)
 !
       RETURN
 !
@@ -570,8 +592,64 @@
          WRITE (ISTDE, *) RECORD(1:LENTH)
       END DO
    29 CLOSE(21)
+      DEALLOCATE(hash_chain)
       STOP
 !
+!   *** 高效的哈希表重复检测函数 ***
+      CONTAINS
+      LOGICAL FUNCTION check_duplicate_hash(current_csf, start_shell, end_shell, num_open)
+         INTEGER, INTENT(IN) :: current_csf, start_shell, end_shell, num_open
+         INTEGER :: hash_val, chain_pos, i, j
+         LOGICAL :: found
+         
+         ! 计算当前CSF的哈希值
+         hash_val = 0
+         DO i = start_shell, end_shell
+            hash_val = MOD(hash_val * 31 + IQ(i, current_csf), HASH_SIZE)
+            hash_val = MOD(hash_val * 31 + JQS(1,i,current_csf), HASH_SIZE)
+            hash_val = MOD(hash_val * 31 + JQS(2,i,current_csf), HASH_SIZE)
+            hash_val = MOD(hash_val * 31 + JQS(3,i,current_csf), HASH_SIZE)
+         END DO
+         DO i = 1, num_open - 1
+            hash_val = MOD(hash_val * 31 + JCUP(i,current_csf), HASH_SIZE)
+         END DO
+         hash_val = hash_val + 1  ! 确保非零
+         
+         ! 在哈希表中查找
+         chain_pos = hash_table(hash_val)
+         found = .FALSE.
+         
+         DO WHILE (chain_pos > 0 .AND. .NOT. found)
+            ! 比较CSF
+            found = .TRUE.
+            DO i = start_shell, end_shell
+               IF (IQ(i, chain_pos) /= IQ(i, current_csf)) THEN
+                  found = .FALSE.
+                  EXIT
+               ENDIF
+               IF (JQS(1,i,chain_pos) /= JQS(1,i,current_csf)) THEN
+                  found = .FALSE.
+                  EXIT
+               ENDIF
+               IF (JQS(2,i,chain_pos) /= JQS(2,i,current_csf)) THEN
+                  found = .FALSE.
+                  EXIT
+               ENDIF
+               IF (JQS(3,i,chain_pos) /= JQS(3,i,current_csf)) THEN
+                  found = .FALSE.
+                  EXIT
+               ENDIF
+            END DO
+            IF (found) THEN
+               DO i = 1, num_open - 1
+                  IF (JCUP(i,chain_pos) /= JCUP(i,current_csf)) THEN
+                     found = .FALSE.
+                     EXIT
+                  ENDIF
+               END DO
+            ENDIF
+            IF (.NOT. found) THEN
+               chain_pos = hash_chain(chain_pos)
+            ENDIF
+         END DO
+         
+         IF (.NOT. found) THEN
+            ! 添加到哈希表
+            hash_chain(current_csf) = hash_table(hash_val)
+            hash_table(hash_val) = current_csf
+         ENDIF
+         
+         check_duplicate_hash = found
+      END FUNCTION check_duplicate_hash
+!
       END SUBROUTINE LODCSL 